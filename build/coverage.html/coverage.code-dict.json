{"/home/travis/build/npmtest/node-npmtest-mdns/test.js":"/* istanbul instrument in package npmtest_mdns */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mdns/lib.npmtest_mdns.js":"/* istanbul instrument in package npmtest_mdns */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mdns = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mdns = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mdns/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mdns && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mdns */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mdns\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mdns.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_mdns.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mdns.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_mdns.__dirname + '/lib.npmtest_mdns.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/mdns.js":"var dns_sd  = require('./dns_sd')\n  , ad      = require('./advertisement')\n  , browser = require('./browser')\n  , st      = require('./service_type')\n  , nif     = require('./network_interface')\n  ;\n\nexports.dns_sd = dns_sd;\n\nexports.Advertisement       = ad.Advertisement;\nexports.createAdvertisement = ad.Advertisement.create;\n\nexports.Browser       = browser.Browser;\nexports.createBrowser = browser.Browser.create;\nexports.browseThemAll = browser.browseThemAll;\nexports.resolve       = browser.resolve;\n\nexports.MDNSService = require('./mdns_service').MDNSService;\n\nexports.ServiceType = st.ServiceType;\nexports.makeServiceType = st.makeServiceType;\nexports.tcp = st.protocolHelper('tcp');\nexports.udp = st.protocolHelper('udp');\n\nexports.loopbackInterface = nif.loopbackInterface;\n\nexports.dns_sd.exportConstants(exports);\n\nexports.rst = require('./resolver_sequence_tasks');\n\nexports.isAvahi = require('./avahi.js');\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/dns_sd.js":"var path = require('path');\nvar major, minor, patch;\n\nif (process.version.match(/^v(\\d+)\\.(\\d+)\\.(\\d+).*$/)) {\n  major = parseInt(RegExp.$1);\n  minor = parseInt(RegExp.$2);\n  patch = parseInt(RegExp.$3);\n}\n\nvar default_dir = major === 0 && minor <= 4 ? 'default' : 'Release'\n  , buildtype = process.env.BUILDTYPE || default_dir\n  ;\n\n//console.log(major, minor, patch, default_dir, buildtype);\n\nfunction product(type) { \n  if (type === 'Coverage') {\n    return path.join('..', 'dns_sd_bindings') \n  }\n  return path.join('..', 'build', type, 'dns_sd_bindings') \n}\n\ntry {\n  module.exports = require(product(buildtype));\n} catch (ex) {\n  if (! ex.code) {\n    if (/not find/.test(ex)) {\n      ex.code = 'MODULE_NOT_FOUND';\n    }\n  }\n  if (ex.code === 'MODULE_NOT_FOUND') {\n    module.exports = require(product(default_dir));\n    console.warn('dns_sd: failed to load requested ', buildtype, 'build. using', default_dir, 'instead.');\n  } else {\n    throw ex;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/advertisement.js":"var dns_sd = require('./dns_sd')\n  , nif = require('./network_interface')\n  , util = require('util')\n  ;\n\nvar MDNSService = require('./mdns_service').MDNSService\n  , makeServiceType = require('./service_type').makeServiceType\n  ;\n\nfunction Advertisement(serviceType, port, options, callback) {\n  MDNSService.call(this);\n  var self = this;\n\n  if ( ! callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n  }\n  options = options || {};\n\n  serviceType = makeServiceType(serviceType);\n\n  var flags     = options.flags          || 0\n    , ifaceIdx  = nif.interfaceIndex(options)\n    , name      = options.name           || null\n    , domain    = options.domain         || null\n    , host      = options.host           || null\n    , txtRecord = options.txtRecord      || null\n    , context   = options.context        || null\n    ;\n\n  if (txtRecord && typeof txtRecord === 'object' &&\n      ! (txtRecord instanceof dns_sd.TXTRecordRef || Buffer.isBuffer(txtRecord)))\n  {\n    txtRecord = objectToTXTRecord(txtRecord);\n  }\n\n  function on_service_registered(serviceRef, flags, errorCode, name,\n      serviceType, domain, context)\n  {\n    var error = dns_sd.buildException(errorCode);\n    if (callback) {\n      callback.call(self, error, {\n          name:    name\n        , type:    makeServiceType(serviceType)\n        , domain:  domain\n        , flags:   flags\n      }, context);\n    }\n    if (error) {\n      self.emit('error', error);\n    }\n  }\n\n  dns_sd.DNSServiceRegister(self.serviceRef, flags, ifaceIdx, name,\n      '' + serviceType, domain, host, port, txtRecord, on_service_registered,\n      context);\n}\nutil.inherits(Advertisement, MDNSService)\nexports.Advertisement = Advertisement;\n\nAdvertisement.create = function create(serviceType, port, options, callback) {\n  return new Advertisement(serviceType, port, options, callback);\n}\n\nAdvertisement.prototype.updateTXTRecord = function updateTXTRecord(txtRecord) {\n  if (txtRecord && typeof txtRecord === 'object' &&\n      ! (txtRecord instanceof dns_sd.TXTRecordRef || Buffer.isBuffer(txtRecord)))\n  {\n    txtRecord = objectToTXTRecord(txtRecord);\n  }\n\n  dns_sd.DNSServiceUpdateRecord(this.serviceRef, null, 0, txtRecord, 0);\n}\n\nfunction objectToTXTRecord(o) {\n  var record = new dns_sd.TXTRecordRef()\n    , value\n    ;\n  record.buffer = new Buffer(256);\n  dns_sd.TXTRecordCreate(record, record.buffer);\n  for (var p in o) {\n    ensure_legal_key(p);\n    if (o[p] === undefined || o[p] === null || Buffer.isBuffer(o[p])) {\n      value = o[p];\n    } else {\n      value = '' + o[p];\n    }\n    dns_sd.TXTRecordSetValue(record, p, value);\n  }\n  return record;\n}\n\nfunction ensure_legal_key(string) {\n  var i, c;\n  for (i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i);\n    if (c < 0x20 || c > 0x7e || c === 0x3d) {\n      throw new Error(\"key must be all printable ascii characters exluding '='\");\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/avahi.js":"var dns_sd = require('./dns_sd');\n\nfunction supportsInterfaceIndexLocalOnly() {\n  try {\n    var sr = new dns_sd.DNSServiceRef()\n      , flags  = 0\n      , iface  = dns_sd.kDNSServiceInterfaceIndexLocalOnly\n      , name   = null\n      , type   = '_http._tcp'\n      , domain = null\n      , host   = null\n      , port   = 4321\n      , txtRec = null\n      , cb     = null\n      , ctx    = null\n      ;\n    dns_sd.DNSServiceRegister( sr, flags, iface, name, type, domain,\n          host, port, txtRec, cb, ctx);\n  } catch (ex) {\n    if (ex.errorCode === dns_sd.kDNSServiceErr_Unsupported) {\n      if (sr && sr.initialized) {\n        dns_sd.DNSServiceRefDeallocate(sr);\n      }\n      return false;\n    }\n    console.warn('Unexpected result while probing for avahi:', ex);\n  }\n  dns_sd.DNSServiceRefDeallocate(sr);\n  return true;\n}\n\nmodule.exports = ! supportsInterfaceIndexLocalOnly();\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/browser.js":"var dns_sd = require('./dns_sd')\n  , nif = require('./network_interface')\n  , util = require('util')\n  , rst = require('./resolver_sequence_tasks')\n  , st = require('./service_type')\n  , MDNSService = require('./mdns_service').MDNSService\n  ;\n\nvar Browser = exports.Browser = function Browser(serviceType, options) {\n  MDNSService.call(this);\n  var self = this;\n\n  options = options || {};\n  var flags = options.flags             || 0\n    , ifaceIdx  = nif.interfaceIndex(options)\n    , domain = options.domain           || null\n    , context = options.context         || null\n    , requested_type = st.makeServiceType( serviceType );\n    ;\n\n  var interfaceNames = [];\n\n  function on_service_changed(sdRef, flags, ifaceIdx, errorCode, serviceName,\n      serviceType, replyDomain, context)\n  {\n    function on_resolver_done(error, service) {\n      if (error) {\n        self.emit('error', error, service);\n      } else {\n        self.emit('serviceChanged', service, context);\n        self.emit('serviceUp', service, context);\n      }\n    }\n    if (errorCode == dns_sd.kDNSServiceErr_NoError) {\n      if (requested_type.isWildcard()) {\n        serviceType = serviceName + '.' + serviceType.split('.').shift();\n        serviceName = null;\n      }\n\n      var type;\n\n      try {\n        type = st.makeServiceType(serviceType);\n      } catch(e) {\n        self.emit('error', e);\n        return;\n      }\n\n      var service = {\n          interfaceIndex: ifaceIdx\n        , type: type\n        , replyDomain: replyDomain\n        , flags: flags\n      };\n      if (serviceName) service.name    = serviceName;\n\n      if (dns_sd.kDNSServiceInterfaceIndexLocalOnly === ifaceIdx) {\n        service.networkInterface = nif.loopbackName();\n      } else if (typeof dns_sd.if_indextoname !== 'undefined' && ifaceIdx > 0) {\n        try {\n          service.networkInterface = dns_sd.if_indextoname(ifaceIdx);\n\n          interfaceNames[ifaceIdx] = service.networkInterface;\n        } catch(e) {\n          if(typeof interfaceNames[ifaceIdx] !== \"undefined\") {\n            service.networkInterface = interfaceNames[ifaceIdx];\n          } else {\n            self.emit('error', e);\n          }\n        }\n      }\n\n      if (flags & dns_sd.kDNSServiceFlagsAdd) {\n        resolve(service,\n            options.resolverSequence || Browser.defaultResolverSequence,\n            on_resolver_done);\n      } else {\n        self.emit('serviceChanged', service, context);\n        self.emit('serviceDown', service, context);\n      }\n    } else {\n      self.emit('error', dns_sd.buildException(errorCode));\n    }\n  }\n\n  dns_sd.DNSServiceBrowse(self.serviceRef, flags, ifaceIdx, '' + requested_type,\n      domain, on_service_changed, context);\n}\nutil.inherits(Browser, MDNSService);\n\nvar resolve = exports.resolve = function resolve(service, sequence, callback) {\n  var step = 0;\n  if ( ! callback) {\n    callback = sequence;\n    sequence = Browser.defaultResolverSequence;\n  }\n\n  function next(error) {\n    if (error) {\n      callback(error, service);\n      return;\n    }\n    if (sequence.length === step) {\n      callback(undefined, service);\n      return;\n    }\n    sequence[step++](service, next);\n  }\n\n  next();\n}\n\nBrowser.create = function create(serviceType, options) {\n  return new Browser(serviceType, options);\n}\n\nBrowser.defaultResolverSequence = [\n  rst.DNSServiceResolve()\n, 'DNSServiceGetAddrInfo' in dns_sd ? rst.DNSServiceGetAddrInfo() : rst.getaddrinfo()\n, rst.makeAddressesUnique()\n];\n\nexports.browseThemAll = function browseThemAll(options) {\n  options = options || {}\n  options.resolverSequence = options.resolverSequence || [];\n  return Browser.create(st.ServiceType.wildcard, options);\n}\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/io_watcher.js":"var dns_sd = require('./dns_sd');\nexports.IOWatcher = typeof dns_sd.SocketWatcher !== 'undefined' ?\n    dns_sd.SocketWatcher : process.binding('io_watcher').IOWatcher;\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/mdns_service.js":"var dns_sd    = require('./dns_sd')\n  , util      = require('util')\n  , events    = require('events')\n  , IOWatcher = require('./io_watcher').IOWatcher;\n  ;\n\nfunction MDNSService() {\n  events.EventEmitter.call(this);\n  var self = this;\n\n  self._watcherStarted = false;\n  self.serviceRef = new dns_sd.DNSServiceRef();\n  self.watcher = new IOWatcher();\n  self.watcher.host = self; // TODO: Find out what this is for ...\n  self.watcher.callback = function() {\n    if (self._watcherStarted) {\n      try {\n        dns_sd.DNSServiceProcessResult.call(self, self.serviceRef);\n      } catch (error) {\n        self.emit(\"error\", error);\n      }\n    }\n  };\n}\nutil.inherits(MDNSService, events.EventEmitter);\nexports.MDNSService = MDNSService;\n\nMDNSService.prototype.start = function start() {\n  if (this._watcherStarted) {\n    throw new Error(\"mdns service already started\");\n  }\n  this.watcher.set(this.serviceRef.fd, true, false);\n  this.watcher.start();\n  this._watcherStarted = true;\n}\n\nMDNSService.prototype.stop = function stop() {\n  if (this._watcherStarted) {\n    this.watcher.stop();\n    dns_sd.DNSServiceRefDeallocate(this.serviceRef);\n    this.serviceRef = null;\n    this._watcherStarted = false;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/network_interface.js":"var net = require('net')\n  , os = require('os')\n  , dns_sd = require('./dns_sd')\n  , interfaceIndexDeprecatedWarningPrinted = false\n  ;\n\nvar have_if_nametoindex = typeof dns_sd.if_nametoindex !== 'undefined';\n\nexports.interfaceIndex = function interfaceIndex(options) {\n  var networkInterface\n    , index = 0;\n  if (typeof options.interfaceIndex !== 'undefined') {\n    if( ! interfaceIndexDeprecatedWarningPrinted) {\n      console.warn(\"WARNING: 'interfaceIndex' is deprecated and will be \" +\n          \"removed. Please use 'networkInterface' instead and see the \" +\n          \"documentation on why it's cool.\");\n      interfaceIndexDeprecatedWarningPrinted = true;\n    }\n    networkInterface = options.interfaceIndex;\n  } else {\n    networkInterface = options.networkInterface;\n  }\n  if (typeof networkInterface !== 'undefined') {\n    if (net.isIP(networkInterface)) {\n      if ( ! have_if_nametoindex) {\n        throw new Error('IP address to interface index conversion is not ' +\n            'supported on this platform');\n      }\n      index = dns_sd.if_nametoindex(addressToName(networkInterface));\n      //console.log('got IP', networkInterface, '->', index);\n    } else if (isString(networkInterface)) {\n      if ( ! have_if_nametoindex) {\n        throw new Error('interface name to index conversion is not supported ' +\n            'on this platform');\n      }\n      index = dns_sd.if_nametoindex(networkInterface);\n      //console.log('got if name', networkInterface, '->', index);\n    } else {\n      //console.log('got index', networkInterface);\n      index = networkInterface;\n    }\n  }\n  //console.log('interface index:', index);\n  return index;\n}\n\nexports.loopbackInterface = function loopbackInterface() {\n  if (typeof dns_sd.kDNSServiceInterfaceIndexLocalOnly !== 'undefined') {\n    return dns_sd.kDNSServiceInterfaceIndexLocalOnly;\n  } else {\n    return loopbackName();\n  }\n}\n\nvar loopbackName = exports.loopbackName = function loopbackName() {\n  var interfaces = os.networkInterfaces();\n  for (var name in interfaces) {\n    for (var i = 0; i < interfaces[name].length; ++i) {\n      if (interfaces[name][i].address === '127.0.0.1') {\n        return name;\n      }\n    }\n  }\n  throw new Error('failed to find loopback interface');\n}\n\nfunction addressToName(address) {\n  if (typeof os.networkInterfaces === 'undefined') {\n    throw new Error('IP address to interface index conversion is not ' +\n        'supported with this version of node');\n  }\n  var addresses = os.networkInterfaces();\n  for (var name in addresses) {\n    for (var i = 0; i < addresses[name].length; ++i) {\n      if (addresses[name][i].address === address) {\n        return name;\n      }\n    }\n  }\n  throw new Error('interface with address ' + address + ' does not exist');\n}\n\nfunction isString(s) {\n  return toString.call(s) == '[object String]';\n}\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/resolver_sequence_tasks.js":"var dns_sd = require('./dns_sd')\n  , util = require('util')\n  , MDNSService = require('./mdns_service').MDNSService\n  ;\n\nexports.DNSServiceResolve = function DNSServiceResolve(options) {\n  options = options || {};\n  options.flags = options.flags || 0;\n  options.unwrapTxtRecord =\n    'unwrapTxtRecord' in options ? options.unwrapTxtRecord : true;\n  return function DNSServiceResolve(service, next) {\n    try {\n      var resolver = new MDNSService();\n\n      function on_resolver_done(sdRef, flags, iface, errorCode, fullname,\n          hosttarget, port, txtRecord, context)\n      {\n        try {\n          var error = dns_sd.buildException(errorCode);\n          if ( ! error && service.interfaceIndex === iface) {\n            if (fullname)       service.fullname = fullname;\n            if (hosttarget)     service.host = hosttarget;\n            if (port)           service.port = port;\n            // all services have a TXT record. ignore the empty ones.\n            if (txtRecord.length > 1) {\n              service.rawTxtRecord = txtRecord;\n              if (options.unwrapTxtRecord) {\n                service.txtRecord = dns_sd.txtRecordBufferToObject(txtRecord)\n              }\n            }\n          }\n          resolver.stop();\n          next(error);\n        } catch (ex) {\n          resolver.stop();\n          next(ex);\n        }\n      }\n\n      dns_sd.DNSServiceResolve(resolver.serviceRef, options.flags,\n          service.interfaceIndex, service.name, '' + service.type,\n          service.replyDomain, on_resolver_done, null);\n      resolver.start();\n    } catch (ex) { \n      resolver.stop();\n      next(ex);\n    }\n  };\n}\n\nexports.DNSServiceGetAddrInfo = function DNSServiceGetAddrInfo(options) {\n  options = options || {};\n  var family_flags = 0;\n  if ('families' in options) {\n    if (options.families.indexOf(4) !== -1) {\n      family_flags |= dns_sd.kDNSServiceProtocol_IPv4;\n    }\n    if (options.families.indexOf(6) !== -1) {\n      family_flags |= dns_sd.kDNSServiceProtocol_IPv6;\n    }\n  }\n  return function DNSServiceGetAddrInfo(service, next) {\n    try {\n      var adr_getter = new MDNSService()\n        , addresses = []\n        ;\n\n      function on_get_addr_info_done(sdRef, flags, iface, errorCode, hostname,\n          address, context)\n      {\n        try {\n          var error = dns_sd.buildException(errorCode);\n          if (error) {\n            adr_getter.stop()\n            next(error);\n          } else {\n            if (iface === service.interfaceIndex) {\n              addresses.push(address);\n            }\n            if ( ! (dns_sd.kDNSServiceFlagsMoreComing & flags)) {\n              service.addresses = addresses;\n              adr_getter.stop()\n              next();\n            }\n          }\n        } catch (ex) {\n          adr_getter.stop();\n          next(ex);\n        }\n      }\n\n      dns_sd.DNSServiceGetAddrInfo(\n          adr_getter.serviceRef, 0, service.interfaceIndex, family_flags,\n          service.host, on_get_addr_info_done, null);\n      adr_getter.start();\n    } catch (ex) {\n      adr_getter.stop();\n      next(ex);\n    }\n  }\n}\n\nvar _getaddrinfo;\ntry {\n  var cares = process.binding('cares_wrap');\n  function getaddrinfo_complete(err, addresses, cb) {\n    if (addresses) {\n      cb(undefined, addresses);\n    } else if (err === 'ENOENT') {\n      cb(undefined, []);\n    } else {\n      cb(errnoException(err, 'getaddrinfo'));\n    }\n  }\n  function getaddrinfo_0_11(host, family, cb) {\n    var req = new cares.GetAddrInfoReqWrap()\n      , err = cares.getaddrinfo(req, host, family)\n      ;\n    req.oncomplete = function oncomplete(err, addresses) {\n        getaddrinfo_complete(err, addresses, cb);\n    }\n    if (err) throw errnoException(err, 'getaddrinfo', host);\n  }\n  function getaddrinfo_0_10(host, family, cb) {\n    var wrap = cares.getaddrinfo(host, family);\n    if ( ! wrap) {\n      throw errnoException(process._errno || global.errno, 'getaddrinfo');\n    }\n    wrap.oncomplete = function (addresses) {\n      getaddrinfo_complete((process._errno || global.errno), addresses, cb);\n    }\n  }\n  // node 0.11+ cares.getaddrinfo function uses request object.\n  // use appropriate version based on node version number\n  if (Number(process.version.match(/^v(\\d+\\.\\d+)/)[1]) > 0.1) {\n    _getaddrinfo = getaddrinfo_0_11;\n  } else {\n    _getaddrinfo = getaddrinfo_0_10;\n  }\n} catch (ex) {\n  _getaddrinfo = process.binding('net').getaddrinfo;\n}\n\nexports.getaddrinfo = function getaddrinfo(options) {\n  options = options || {};\n  var families = options.families || [4, 6];\n  return function getaddrinfo(service, next) {\n    var last_error\n      , counter = 0\n      ;\n    // XXX in older versions of node a zero family value is not supported\n    families.forEach(function(family) {\n      _getaddrinfo(service.host, family, function(error, addresses) {\n        if (error) {\n          last_error = error\n        } else {\n          service.addresses = (service.addresses || []).concat(addresses);\n        }\n        if (++counter === families.length) {\n          next(last_error);\n        }\n      });\n    });\n  }\n}\n\nfunction unique(array) {\n  var o = {} , p , r = [] ;\n  array.forEach(function(e) { o[e] = undefined });\n  for (p in o) { r.push(p) }\n  return r;\n}\n\nexports.makeAddressesUnique = function makeAddressesUnique() {\n  return function makeAddressesUnique(service, next) {\n    service.addresses = unique(service.addresses);\n    next();\n  }\n}\n\nexports.filterAddresses = function filterAddresses(filter_function) {\n  return function filterAddresses(service, next) {\n    service.addresses = (service.addresses || []).filter(filter_function);\n    next();\n  }\n}\n\nexports.logService = function logService() {\n  return function logService(service, next) {\n    console.log(service);\n    next();\n  }\n}\n\nfunction errnoException(errorno, syscall) {\n  // TODO make this more compatible with ErrnoException from src/node.cc\n  // Once all of Node is using this function the ErrnoException from\n  // src/node.cc should be removed.\n  var e = new Error(syscall + ' ' + errorno);\n\n  // For backwards compatibility. libuv returns ENOENT on NXDOMAIN.\n  if (errorno == 'ENOENT') {\n    errorno = 'ENOTFOUND'\n  }\n\n  e.errno = e.code = errorno;\n  e.syscall = syscall;\n  return e;\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/lib/service_type.js":"var ServiceType = exports.ServiceType = function ServiceType(/* ... */) {\n  this.name = '';\n  this.protocol = '';\n  this.subtypes = [];\n\n  var args;\n  if (arguments.length === 1) {\n    args = Array.isArray(arguments[0]) ? arguments[0] : [arguments[0]];\n  } else if (arguments.length > 1) {\n    args = Array.prototype.slice.call(arguments);\n  }\n  if (args) {\n    if (args.length === 1) {\n      if (typeof args[0] === 'string') {\n        this.fromString(args[0]);\n      } else if (Array.isArray(args[0])) {\n        this.fromArray(args[0]);\n      } else if (typeof args[0] === 'object') {\n        this.fromJSON(args[0]);\n      } else {\n        throw new Error('argument must be a string, array or object');\n      }\n    } else if (args.length >= 2) {\n      this.fromArray(args);\n    } else { // zero arguments\n      // uninitialized ServiceType ... fine with me\n    }\n  }\n}\n\nServiceType.wildcard = '_services._dns-sd._udp.';\nServiceType.prototype.isWildcard = function isWildcard() {\n  return this.toString() === ServiceType.wildcard;\n}\n\nServiceType.prototype.toString = function() {\n  var type_string = _u(this.name) + \".\" + _u(this.protocol);\n  if (this.fullyQualified) {\n    type_string += '.'\n  }\n  if (this.subtypes.length > 0) {\n    var subtypes = this.subtypes.map(function(t) { return _u(t) });\n    subtypes.unshift(type_string);\n    type_string = subtypes.join(',');\n  }\n  return type_string;\n}\n\nServiceType.prototype.fromString = function fromString(string) {\n  var is_wildcard = string === ServiceType.wildcard\n    , subtypes = string.split(',')\n    , primary_string = subtypes.shift()\n    , service_tokens = primary_string.split('.')\n    , service_type = service_tokens.shift()\n    , protocol\n    ;\n  if (is_wildcard) {\n    service_type += '.' + service_tokens.shift();\n  }\n  protocol = service_tokens.shift()\n\n  checkProtocolU(protocol);\n  if ( ! is_wildcard) {\n    checkFormat(service_type);\n  }\n  subtypes.forEach(function(t) { checkFormat(t) });\n  if (service_tokens.length === 1 && service_tokens[0] === '') {\n    // trailing dot\n    this.fullyQualified = true\n  } else if (service_tokens.length > 0) {\n    throw new Error(\"trailing tokens '\" + service_tokens.join('.') + \"' in \" +\n        \"service type string '\" + string + \"'\");\n  }\n\n  this.name = service_type.substr(1);\n  this.protocol = protocol.substr(1);\n  this.subtypes = subtypes.map(function(t) { return t.substr(1) });\n}\n\nServiceType.prototype.toArray = function toArray() {\n  return [this.name, this.protocol].concat(this.subtypes);\n}\n\nServiceType.prototype.fromArray = function fromArray(array) {\n  var service_type = _uu(array.shift())\n    , protocol = _uu(array.shift())\n    , subtypes = array.map(function(t) { return _uu(t) })\n    ;\n  checkLengthAndCharset(service_type);\n  checkProtocol(protocol);\n  subtypes.forEach(function(t) { checkLengthAndCharset(t) });\n\n  this.name = service_type;\n  this.protocol = protocol;\n  this.subtypes = subtypes\n}\n\nServiceType.prototype.fromJSON = function fromJSON(obj) {\n  if ( ! ('name' in obj)) {\n    throw new Error('required property name is missing');\n  }\n  if ( ! ('protocol' in obj)) {\n    throw new Error('required property protocol is missing');\n  }\n\n  var service_type   = _uu(obj.name)\n    , protocol       = _uu(obj.protocol)\n    , subtypes       = 'subtypes' in obj ?\n                        obj.subtypes.map(function(t) { return _uu(t) }) : []\n    ;\n\n  checkLengthAndCharset(service_type);\n  checkProtocol(protocol);\n  subtypes.forEach(function(t) { checkLengthAndCharset(t) });\n\n  this.name = service_type;\n  this.protocol = protocol;\n  this.subtypes = subtypes;\n  if ('fullyQualified' in obj) {\n    this.fullyQualified = obj.fullyQualified;\n  }\n}\n\nServiceType.prototype.matches = function matches(other) {\n  return this.name === other.name && this.protocol === other.protocol;\n  // XXX handle subtypes\n}\n\nexports.makeServiceType = function makeServiceType() {\n  if (arguments.length === 1 && arguments[0] instanceof ServiceType) {\n    return arguments[0];\n  }\n  return new ServiceType(Array.prototype.slice.call(arguments));\n}\n\nexports.protocolHelper = function protocolHelper(protocol) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (isProtocol(args[1])) {\n      throw new Error(\"duplicate protocol '\" + args[1] + \"' in arguments\");\n    }\n    args.splice(1,0, protocol);\n    return exports.makeServiceType.apply(this, args);\n  }\n}\n\nfunction isProtocol(str) {\n  return str === 'tcp' || str === '_tcp' || str === 'udp' || str === '_udp';\n}\n\nfunction _u(str) { return \"_\" + str; }\nfunction _uu(str) { return str[0] === '_' ? str.substr(1) : str; }\n\nvar charset_regex = /[^-a-zA-Z0-9]/;\nfunction checkLengthAndCharset(str) {\n  if (str.length === 0) {\n    throw new Error('type ' + str + ' must not be empty');\n  }\n  if (str.length > 15) {\n    throw new Error('type ' + str + ' has more than 15 characters');\n  }\n  if (str.match(charset_regex)) {\n    throw new Error('type ' + str + ' may only contain alphanumeric ' +\n        'characters and hyphens');\n  }\n}\n\nvar format_regex = /_[-a-zA-Z0-9]+/;\nfunction checkFormat(str) {\n  if (str.length === 0) {\n    throw new Error('type string must not be empty');\n  }\n  if (str.length > 16) { // 16 is correct because we have a leading underscore\n    throw new Error('type ' + _uu(str) + ' has more than 15 characters');\n  }\n  if ( ! str.match(format_regex)) {\n    throw new Error('type ' + str + ' must start with an underscore ' +\n        'followed by alphanumeric characters and hyphens only');\n  }\n}\n\nfunction checkProtocolU(str) {\n  if ( ! (str === '_tcp' || str === '_udp')) {\n    throw new Error(\"protocol must be either '_tcp' or '_udp' but is '\" +\n        str + \"'\");\n  }\n}\n\nfunction checkProtocol(str) {\n  if ( ! (str === 'tcp' || str === 'udp')) {\n    throw new Error(\"protocol must be either '_tcp' or '_udp' but is '\" +\n        str + \"'\");\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/actors.js":"var fs = require('fs')\n  , child_process = require('child_process')\n  , _glob = require('glob')\n  , bunch = require('./bunch')\n  ;\n\nexports.loadEnv = function loadEnv(env, cb) {\n  var loaders = []\n  function load(name, cb) {\n    fs.readFile(env[name], function(error, data) {\n      env[name] = env[name].match(/.*\\.json$/) ?  JSON.parse(data) : data;\n      cb(error, data)\n    })\n  }\n  for (var name in env) {\n    loaders.push([load, name])\n  }\n  bunch(loaders, cb)\n}\n\nexports.commandActor = function command(executable) {\n  return function command(args, opts, cb) {\n    if (!cb) {\n      cb = opts;\n      opts = {}\n    }\n    var cmd = child_process.spawn(executable, args, opts);\n    function log(b) { console.log(b.toString()) } \n    cmd.stdout.on('data', log);\n    cmd.stderr.on('data', log);\n    cmd.on('exit', function(code) {\n      if (code) {\n        cb(new Error(executable + ' exited with status ' + code));\n      } else {\n        cb();\n      }\n    });\n    return cmd;\n  }\n}\n\nexports.jsonParse = function(str, cb) {\n  try {\n    cb(null, JSON.parse(str));\n  } catch (ex) {\n    cb(ex);\n  }\n}\n\nexports.jsonStringify = function(obj, cb) {\n  try {\n    cb(null, JSON.stringify(obj));\n  } catch (ex) {\n    cb(ex);\n  }\n}\nexports.glob = function glob(pattern, cb) {\n  console.log('pattern', pattern);\n  _glob(pattern, function(error, files) {\n    cb(error, [files]);\n  });\n}\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/bunch.js":"module.exports = function bunch(tasks, cb) {\n  var count = 0, has_error;\n  function done(error) {\n    if (error) {\n      has_error = error;\n      cb(error);\n    }\n    if (++count === tasks.length && ! has_error) cb();\n  }\n  tasks.forEach(function(t) { t[0].apply(null, t.slice(1).concat([done])) });\n}\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/compiler.js":"\nvar fs     = require('fs')\n  , path = require('path')\n  , mkdirp = require('mkdirp')\n  , obj = require('./obj')\n  ;\n\nexports.compiler = function compiler(f, name, options) {\n  options = options || {};\n  return function(src, dst, dynamic_options, cb) {\n    if ( ! cb ) {\n      cb = dynamic_options;\n      dynamic_options = {};\n    }\n    var all_options = resolve_options(src, dst, options, dynamic_options)\n    fs.readFile(src, function(error, data) {\n      if (error) return cb(error);\n      f(data.toString(), all_options, function(error, result) {\n        if (error) {\n          cb(error);\n        } else {\n          mkdir_and_write_file(dst, result, cb);\n        }\n      });\n    });\n  }\n}\n\nexports.compilerSync = function compilerSync(f, name, options) {\n  options = options || {};\n  return function(src, dst, dynamic_options, cb) {\n    if ( ! cb ) {\n      cb = dynamic_options;\n      dynamic_options = {};\n    }\n    console.log('[' + name + ']', dst)\n    var all_options = resolve_options(src, dst, options, dynamic_options)\n    fs.readFile(src, function(error, data) {\n      if (error) return cb(error);\n      var result = f(data.toString(), all_options);\n      mkdir_and_write_file(dst, result, cb);\n    });\n  }\n}\n\nexports.src = {};\nexports.dst = {};\n\nfunction resolve_options(src, dst /*, options, ... */) {\n  var option_objects = Array.prototype.slice.call(arguments, 2)\n    , options = obj.union.apply(null, option_objects);\n  for (var opt in options) {\n    if (options[opt] === exports.src) {\n      options[opt] = src;\n    } else if (options[opt] === exports.dst) {\n      options[opt] = dst;\n    }\n  }\n  return options;\n}\n\nfunction mkdir_and_write_file(file, content, cb) {\n  mkdirp(path.dirname(file), function(error) {\n    if (error) {\n      cb(error)\n    } else {\n      fs.writeFile(file, content, cb)\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/lcov.js":"\nvar fs = require('fs')\n  ;\nexports.infoFileToJson = function infoFileToJson(filename, filefilter, cb) {\n  var input = fs.createReadStream(filename)\n  var parser = new LcovLoader(filefilter)\n  function process_lcov_chunk(chunk) { parser.consume(chunk); }\n  input.on('data', process_lcov_chunk);\n  input.on('end', function() {\n    //process.stdout.write(JSON.stringify(parser.result, null, 2));\n    cb(null, parser.result)\n  });\n}\n\n\n\nvar LcovLoader = exports.LcovLoader = function LcovLoader(filefilter) {\n  this.tail = ''\n  this.result   = {\n      files: {}\n    , tests: {}\n    , functionCount: {}\n  }\n  this.testname = '';\n  this.filename = '';\n  this.filefilter = filefilter || function() { return true };\n}\nLcovLoader.prototype =\n{ tail: ''\n, result: {}\n, testname: ''\n, filename: ''\n, filefilter: null\n}\n\nLcovLoader.prototype.consume = function consume(chunk) {\n  var self = this\n    , lines = chunk.toString().split('\\n')\n    ;\n  if (this.tail) { lines[0] = this.tail + lines[0]; }\n  this.tail = lines.pop()\n\n  var testname = self.testname\n    , filename = self.filename\n    , result = self.result\n    , functionCount = result.functionCount\n    , file = result.files[filename]\n    , test = result.tests[filename]\n    , count = 0\n    , warn_negative = false\n    ;\n  function consumeLine(line) {\n    if (line.match(/^TN:([^,]*)(,diff)?/)) {\n      testname = (RegExp.$1 || '') + (RegExp.$2 || '');\n      if (testname) result.tests[testname] = {functionCount: {} };\n    } else if (line.match(/^[SK]F:(.*)/)) {\n      filename = RegExp.$1;\n      if (self.filefilter(filename)) {\n        if (!result.files[filename]) result.files[filename] = {};\n        file = result.files[filename];\n        //console.log('file:', filename, file)\n        if (testname) {\n          if (!result.tests[testname]) result.tests[testname] = {};\n          test = result.tests[testname];\n        } else {\n          test = null;\n        }\n      } else {\n        file = null\n      }\n    } else if (line.match(/^DA:(\\d+),(-?\\d+)(,[^,\\s]+)?/)) {\n      if (!file) { \n        return\n      }\n      count = parseInt(RegExp.$2)\n      if (count < 0) {\n        count = 0;\n        warn_negative = true;\n      }\n      if (!file.lines) file.lines = {};\n      if (!file.lines[RegExp.$1]) file.lines[RegExp.$1] = 0\n      file.lines[RegExp.$1] += count;\n      if (test) {\n        if (!test.lines) test.lines = {};\n        if (!test.lines[RegExp.$1]) test.lines[RegExp.$1] = 0;\n        test.lines[RegExp.$1] += count;\n      }\n    } else if (line.match(/^FN:(\\d+),([^,]+)/)) {\n      if (!file) { \n        return\n      }\n      if (!file.functions) file.functions = {};\n      file.functions[RegExp.$2] = {};\n      file.functions[RegExp.$2].line = parseInt(RegExp.$1);\n      functionCount[RegExp.$2] = 0;\n      if (test && ! test.functionCount[RegExp.$2]) test.functionCount[RegExp.$2] = 0\n    } else if (line.match(/^FNDA:(\\d+),([^,]+)/)) {\n      if (!file) { \n        return\n      }\n      functionCount[RegExp.$2] += parseInt(RegExp.$1);\n    } else if (line.match(/^BRDA:(\\d+),(\\d+),(\\d+),(\\d+|-)/)) {\n      if (!file) {\n        return\n      }\n      if (!file.branches) { file.branches = {} }\n      var line = RegExp.$1\n        , block = RegExp.$2\n        , branch = RegExp.$3\n        , taken  = RegExp.$4\n        ;\n      if(!file.branches[block]) {file.branches[block] = {}};\n      if(!file.branches[block][branch]) {file.branches[block][branch] = 0};\n      file.branches[block][branch] += parseInt(taken);\n      //console.log('line:', line, 'block:', block, 'branch:', branch, 'taken:', taken)\n    } else if (line.match(/^end_of_record/)) {\n    } else {\n      //console.log('unhandled:', line)\n    }\n  }\n\n  lines.forEach(consumeLine);\n\n  self.filename = filename;\n  self.testname = testname;\n}\n\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/ncov.js":"#!/usr/bin/env node\n\nvar fs = require('fs')\n  , path = require('path')\n  , nopt = require('nopt')\n  , mm = require('minimatch')\n  , lcov = require('./lcov')\n  , slide = require('slide')\n  , ejs = require('ejs')\n  , mkdirp = require('mkdirp')\n  , view = require('./view')\n  , obj = require('./obj')\n\n  , knownOptions =\n    { match    : String\n    , template : path\n    }\n  , parsedOptions = nopt(knownOptions)\n  , rootd = path.resolve(__dirname, '..', '..')\n  ;\n\nvar filefilter = mm.Minimatch(parsedOptions.match || rootd + '/**');\nfilter = function(f) { return filefilter.match(f) };\n\nvar chain = slide.chain\n  , meta = {}\n  , outd = path.join(rootd, 'build')\n  , pagedir = path.join(outd, 'pages')\n  , docd = path.join(rootd, 'doc')\n  , lcov_info_file = path.join(outd, 'reports', 'coverage', 'cpp', 'testrun_all.info')\n  , json_report = path.join(outd, 'reports', 'coverage', 'testrun_coverage-cpp.json')\n  , prerequisites =\n    { layout: path.join(docd, 'layout.ejs')\n    , source_template: path.join(docd, 'build', 'source.ejs')\n    }\n  ;\n\nchain( [ [ load_prerequisites, meta, prerequisites]\n       , [ lcov.infoFileToJson, lcov_info_file, filter]\n       , [ save_json, chain.last, json_report]\n       , [ render_pages, chain.last]\n       ]\n     , function(error) {\n         console.log('done', error);\n         if (error) { process.exit(1) }\n       }\n     );\n\nfunction save_json(report, file, cb) {\n  fs.writeFile(file, JSON.stringify(report, null, 2), function(err) {\n    console.log('================================================================================');\n    console.log('testrun c++ coverage report saved to', file.replace(/.*\\/(build\\/.*)/, \"$1\"));\n    console.log('================================================================================');\n    cb(err, report);\n  });\n}\n\nfunction render_pages(coverage, cb) {\n  var pages = Object.keys(coverage.files)\n    , stripped_names = strip_common_path(pages, 1)\n    , funcs = pages.map(function(p,i) {\n        return [render_source_page, p, stripped_names[i], coverage.files[p], coverage.functionCount, meta]\n      })\n    ;\n  bunch(funcs, cb);\n}\n\nfunction render_source_page(file, stripped_name, coverage, functions, meta, cb) {\n  var outfile = path.join(pagedir, 'coverage', stripped_name) + '.html';\n  chain( [ [ fs.readFile, file ]\n         , [ render_source_view, chain.last, stripped_name, coverage, functions, outfile, meta ]\n         , [ mkdirp, path.dirname(outfile) ]\n         , [ fs.writeFile, outfile, chain.last ]\n         ]\n       , cb\n       )\n}\n\nfunction pad(n, len) {\n  var str = '' + n;\n  while (str.length < len) { str = ' ' + str }\n  return str\n}\n\nfunction hit_counts(coverage, line_count) {\n  var hit_lines = [];\n  for (var i = 1; i <= line_count; ++i) {\n    if (coverage.lines[i]) {\n      hit_lines.push(coverage.lines[i])\n    } else {\n      hit_lines.push(0)\n    }\n  }\n  var num_digits = number_of_digits( Math.max.apply(null, hit_lines))\n    ;\n  return hit_lines.map(function(lc) { return lc ? pad(lc, num_digits) : '&nbsp;' }).join('\\n')\n}\n\nfunction number_of_digits(n) { return Math.ceil(Math.log(n)/Math.LN10) }\n\nfunction render_source_view(source, name, coverage, functions, dst, meta, cb) {\n  var lines = source.toString().split('\\n')\n    ;\n  if (lines[lines.length - 1] === '') {\n    lines.pop()\n  }\n\n  var metadata =\n    { stylesheets: \n      [ '/stylesheets/mdns.css'\n      , '/stylesheets/build_status.css'\n      ]\n    , scripts: []\n    , title: 'Test Coverage of ' + name\n    };\n  var locals = { lines: lines\n               , coverage: coverage\n               , path: name.split('/')\n               , escape: require('ejs/lib/utils').escape\n               , counts: found_and_hit(coverage, functions)\n               };\n  locals = obj.union(locals, view.helpers(metadata, {outputDir: pagedir, dst: dst}));\n  metadata.body = ejs.render(meta.source_template.toString(), locals);\n  metadata.path = view.getPathHelper({outputDir: pagedir, dst: dst});\n  var html = ejs.render(meta.layout.toString(), metadata);\n  cb(null, html);\n}\n\nfunction found_and_hit(coverage, function_calls) {\n  var result = { lines:     {found: 0, hit: 0}\n               , functions: {found: 0, hit: 0}\n               , branches:  {found: 0, hit: 0}\n               };\n  function fnh(things, out) {\n    for (var p in things) {\n      out.found += 1;\n      if (things[p] > 0) {\n        out.hit += 1;\n      }\n    }\n  }\n  fnh(coverage.lines, result.lines);\n  for (var f in coverage.functions) {\n    result.functions.found += 1;\n    if (function_calls[f] > 0) {\n      result.functions.hit += 1;\n    }\n  }\n  return result;\n}\n\nfunction load(file, data, name, cb) {\n  fs.readFile(file, function(error, content) {\n    if (error) { cb(error); return }\n    data[name] = content;\n    cb()\n  });\n}\n\nfunction load_prerequisites(data, things, cb) {\n  var funcs = [];\n  for (var p in things) {\n    funcs.push([load, things[p], data, p]);\n  }\n\n  bunch(funcs, cb);\n}\n\n\nfunction strip_common_path(names, keep_common) {\n  var paths = names.map(function(n) {return n.split('/')})\n    , common_elements = 0\n    , first\n    , all_equal = true;\n    ;\n  while (all_equal) {\n    first = paths[0][common_elements];\n    all_equal = paths.every(function(p) { return p[common_elements] === first});\n    if (all_equal) common_elements += 1;\n  }\n  common_elements -= 1;\n  common_elements -= keep_common;\n  if (common_elements < 0) {\n    return\n  }\n\n  return paths.map(function(p) { return p.slice(common_elements).join('/') })\n\n}\n\nfunction bunch(things, cb) {\n  var count = 0, has_error;\n  function done(error) {\n    count += 1;\n    if (error && ! has_error) {\n      has_error = error;\n      cb(error);\n    }\n    if ( ! has_error && count == things.length) {\n      cb();\n    }\n  }\n  things.forEach(function(t) { t[0].apply(null, t.slice(1).concat([done])) });\n}\n\n// vim: filetype=javascript :\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/obj.js":"exports.union = function union(/* object, object, ... */)  {\n  if (arguments.length < 2) {\n    throw new Error('union() requires at least two arguments');\n  }\n  var result = {};\n  for (var i in arguments) {\n    for (var p in arguments[i]) {\n      result[p] = arguments[i][p];\n    }\n  }\n  return result;\n}\n","/home/travis/build/npmtest/node-npmtest-mdns/node_modules/mdns/utils/lib/view.js":"\nvar path = require('path')\n  , ejs = require('ejs')\n  , obj = require('./obj')\n  ;\n\nexports.make_relative = function make_relative(paths, dst, root) {\n  var result = [];\n  var r = dst.substr(0, root.length);\n  if ( r !== root) {\n    console.log('KAPUTT');\n  }\n  dst = dst.substr(root.length)\n  return paths.map(function(p) { return path.relative(path.dirname(dst), p) });\n}\n\nvar helpers = exports.helpers = function helpers(ctx, options) {\n  options = options || {};\n  var helpers = {};\n  helpers.title = function title(t) { if(t) {ctx.title = t} return ctx.title }\n  helpers.script = function script(s) { ctx.scripts.push(s) }\n  helpers.stylesheet = function stylesheet(s) { ctx.stylesheets.push(s) }\n  helpers.path = exports.getPathHelper(options)\n  return helpers;\n}\n\nfunction passthrough(p) { return p }\n\nexports.getPathHelper = function getPathHelper(options) {\n  if (options.outputDir) {\n    return function _path(p) {\n      var r = options.dst.substr(0, options.outputDir.length);\n      if ( r !== options.outputDir) { throw new Error('KAPUTT') }\n      var dst = options.dst.substr(options.outputDir.length);\n      var relpath =  path.relative(path.dirname(dst), p);\n      return relpath;\n    }\n  } else {\n    return function _path(p) { return p }\n  }\n}\n\n\nexports.render = function render(source, options, cb) {\n  var metadata = { stylesheets: [], scripts: []}\n    , locals = helpers(metadata, options)\n    ;\n  locals = obj.union(options.locals || {}, locals);\n  metadata.body = ejs.render(source, locals);\n  metadata.path = exports.getPathHelper(options);\n  var html = ejs.render(options.layout.toString(), metadata);\n  cb(null, html);\n}\n"}